using System.Collections.Immutable;
using System.Diagnostics;

namespace Bitsquid;

/// Class for generating HTML code.
///
/// The code is generated by calling add() multiple times to add lines of HTML content enclosed in
/// particular tags. When all the data has been added, generate() is called to generate the final
/// document. The generator takes caring of adding open- and close- tags so that every line gets
/// the required tags. It also formats the HTML in a nice way.
///
/// Example:
///
///    require_relative 'generator'
///    
///    gen = Bitsquid::Generator.new()
///    gen.add(%w(h1), "Header")
///    gen.add(%w(ul li p),  "One item")
///    gen.add(%w(ul), null)
///    gen.add(%w(ul li p), "One item")
///    gen.add(%w(ul li p), "with two lines")
///    puts(gen.generate())
///
/// Result:
///
///    <h1>Header</h1>
///    
///    <ul>
///    	<li><p>One item</p></li>
///    	<li>
///    		<p>
///    			One item
///    			with two lines
///    		</p>
///    	</li>
///    </ul>
public class Generator {
    public record GenLine(ImmutableArray<string?> Context, string? Line)
    {
        public override string ToString()
        {
            return $"<[{string.Join(", ", Context)}] {Line}>";
        }
    }

    private static bool IsSameContext(IEnumerable<string?> lhsi, IEnumerable<string?> rhsi)
    {
		var lhs = lhsi.ToImmutableArray();
		var rhs = rhsi.ToImmutableArray();
        if (lhs.Length != rhs.Length)
        {
            return false;
        }

        for (int i = 0; i < lhs.Length; i++)
        {
            if (lhs[i] != rhs[i]) return false;
        }

        return true;
    }

	/// Accessor for accessing the lines of the document. Each line is a struct with
	/// two fields, :context for the list of tags and :line for the text.
	public List<GenLine> Lines {get; init;} = new();

	/// Adds a new line to the HTML document. context is the list of tags that the
	/// line should use. E.g., if the context is %w(ul li p) the line will be enclosed
	/// in <ul><li><p>
	///
	/// When generating the output, contexts are merged with neighboring lines, the tags
	/// that don't match the tags of the previous line are automatically opened and closed.
	///
	/// You can use null for the line text to create empty tags.
	///
	/// Tags in the context can include parameters, as in: ["div class=\"menu\"", "h1"]
	public void AddWithArray(ImmutableArray<string?> context, string? line) {
		this.Lines.Add(new GenLine(context, line));
	}

    public void Add(string? line, params string?[] context)
    {
		AddWithArray(context.ToImmutableArray(), line);
    }

	/// Generates the HTML document and returns it as a string.
	private List<string> _out = new();
	private List<string> _context = new();
	
	public string Generate() {
		this._out = new();
		this._context = new();

        trim_nil_lines();

		foreach(var (line, i) in this.Lines.each_with_index()) {
			write_with_context(line!.Line, line!.Context, next_context(i));
		}
		write_with_context(null, ImmutableArray<string?>.Empty, ImmutableArray<string?>.Empty);
		return string.Join("", this._out);
	}

	private void trim_nil_lines()
    {
		int i = 0;
		while(i+1 < this.Lines.Count) {
			var a = this.Lines[i];
			var b = this.Lines[i+1];

            var a1 = a.Line == null;
            var a2 = a.Context == b.Context;
            var rhs = b.Context.Slice(0, Math.Min(b.Context.Length, a.Context.Length));
            var a3 = IsSameContext(a.Context, rhs) == false;

            if (a.Line == null && (a.Context.SequenceEqual(b.Context) || !a.Context.SequenceEqual(b.Context.Take(a.Context.Length))))
            {
				this.Lines.RemoveAt(i);
			} else {
				i += 1;
			}
		}
	}

	private void pop_whitespace() {
		while( string.IsNullOrWhiteSpace(this._out.Last()))
		{
			this._out.RemoveAt(this._out.Count - 1);
		}
	}

	private ImmutableArray<string?> next_context(int i) {
        var r  = i + 1 < this.Lines.Count
            ? this.Lines[i + 1].Context
            : ImmutableArray<string?>.Empty;
        return r;
    }
	
	private string first_word(string t) {
		return t.Split(' ').First();
	}

	private void write_with_context(string? line, ImmutableArray<string?> context, ImmutableArray<string?> next_context) {
		while( this._context.Count > 0 && (
                  this._context.Count > context.Length
                  || Check()) ) {
			close_context();
		}

		int i = this._context.Count;
		while(context.Length > i && i < next_context.Length && context[i] == next_context[i] ) {
			open_context(context[i]);
			i = i+1;
		}

		if(line != null) {
			if(this._context.Count == 0 && this._out.Count > 0) puts("");
			var tags = context[i..];
			var start = string.Join("", tags.Select(t => $"<{t}>"));
			var stop = string.Join("", tags.Reverse().Select(t => $"</{first_word(t)}>"));
			puts(start + line + stop);
		}

        bool Check()
        {
            var lhs = this._context.Last();
            var rhs = context[this._context.Count - 1];
            var different =  lhs != rhs;
            return different;
        }
    }

	private void open_context(string tag) {
        if(this._context.Count == 0 && this._out.Count > 0) puts("");
		puts($"<{tag}>");
		this._context.Add(tag);
		if(first_word(tag) == "pre") pop_whitespace();
	}

	private void close_context() {
		var tag = this._context.pop();
		if(first_word(tag) == "pre") {
			pop_whitespace();
			this._out.Add("</pre>" + "\n");
		}
		else {
			puts($"</{first_word(tag)}>");
		}
	}

	private void puts(string text) {
        if(this._context.Count > 0 && first_word(this._context.Last()) == "pre") {}
		else{ this._out.Add(new string('\t', this._context.Count));}
		this._out.Add(text + "\n");
	}
}
